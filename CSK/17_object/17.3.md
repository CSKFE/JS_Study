*** 내부 메서드 [[Call]] [[Construct]] ***

일반적인 함수 표현식, 선언문으로 정의된 함수는 일반함수로써 호출도 가능하다
하지만 new 연산자를 사용해서 생성자 함수로써도 호출이 가능하다.

함수도 객체이기때문에 함수내부 메서드도 객체 내부메서드와 동일하다
일반 객체는 호출할 수 없다, 하지만 함수는 호출이 가능하다.
하지만 함수 내부메서드는 [[Call]]과 [[Construct]]가 존재한다
일반적인 함수로써 호출될때 내부 메서드 [[Call]]이 호출되며 이를 가진 함수를 callarble 라고 한다
생성자 함수로 new 연산자와 함께 호출될때 [[Construct]]가 호출된다

일반 객체는 호출할 수 없기때문에 callarble 일 수 없지만, 함수객체는 호출이 가능하기때문에 모든 함수객체는 callarble 이다.
하지만 모든 함수객체가 constructor이진 않다.
생성자 함수로 호출할 수 없는 함수객체를 non-constructor 라고한다

constructor 함수 - 일반 함수 표현식, 선언문으로 생성된 함수, 클래스
non-constructor 함수 - 메서드(ES6 선언된 문법), 화살표 함수

non-constructor 함수를 new 연산자와 함께 호출하면 에러가 발생한다.

*** new 연산자 ***
생성자 함수도 일반 함수처럼 호출이 가능하다.
new 연산자를 사용하지 않고 생성자 함수를 호출하게되면 일반함수 호출이된다
일반함수 호출이기때문에 [[Call]]이 호출되어 callable이 된다

일반 함수(함수 선언문, 표현식, 클래스 , ES6 축약표현으로 정의하지않고 일반 정의된 메서드)도 new 연산자로 호출이 가능하다
이때 생성자 함수로 호출이기때문에 [[Call]]이 아닌 [[Construct]]가 호출되어 constructor가 된다

*** new.target ***
ES6에 추가된 new.target 은 호출된 constructor 함수의 지역스코프로 사용되며 함수 자신을 가리킨다. 만약 new 연산자 없이 호출된 constructor면 undefined를 반환한다.
***메타 프로퍼티*** 라고 부른다
