//챕터 4 - 변수
//변수 - 프로그래밍 언어에서 데이터를 관리하기위함
// 하나의 값을 저장하기 위해 확보한 메모리공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름

//하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = "Choi";

//객체 혹은 배열같은 자료구조를 사용하면 여러 값을 하나로 그룹화 할 수 있음
var user = {id : 1, name : 'Choi'};
var users = [{
  id : 1,
  name : 'Choi',
},
{
  id : 2,
  name : 'Lee',
}];

var result = 10 + 20;
//해당 연산은 10 + 20 연산을 통해 30이라는 새로운 값을 생성한다.
// 연산을 통해 생성된 값은 메모리에 저장된다.
// 이때 메모리에 저장된 값 30을 다시 읽어들여 재사용 할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙힌것이 변수다.
// 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수명, 변수에 저장된 값을 변수 값 이라고 한다


//변수에 값을 저장하는 것을 할당(assignment)이라 하고, 변수에 저장된 값을 읽는것을 참조(reference)라고 한다

//변수명을 통해서 저장된 값의 의미를 명확하게 할 수 있다. 따라서 변수의 값을 파악할 수 있도록 변수명을 짓는것도 중요하다

/* 식별자 */

//변수 이름을 식별자(identifier)라고도 한다.
//마치 사람을 이름으로 구분하듯 값도 마찬가지다

//위의 예제와같이 result는 값30이 저장되어있는 메모리 주소를 기억해야한다.
//이처럼 식별자는 값이 아닌 값이 담겨있는 메모리 주소를 기억하고 참조한다.

/* 변수 선언 */
// 변수 선언이란?
// 변수를 생성하는 것, 값을 저장하기 위한 메모리를 확보, 변수이름과 확보된 메모리공간의 주소를 연결(binding)할 수 있게끔 준비하는 것
//자바스크립트 변수 키워드 var, let, const

// 키워드란 ? - 자바스크립트 코드를 해석하고 엔진이 수행할 동작을 규정한 명령어다.
var score;

//아직 할당 전 이므로 메모리가 비어있을거 같으나 자바스크립트 엔진은 undefined가 암묵적으로 할당되어있다.

//자바스크립트 엔진은 변수 선언을 2가지 단계로 거쳐 수행한다
// 1. 선언 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
// 2. 초기화 : 값을 저장하기 위한 메모리 공간을 확보 후 undefind를 할당해 초기화

// 변수를 사용하려면 반드시 선언이 필요한다.(변수 뿐 아니라 모든 식별자 동일)
// 선언하지 않은 식별자에 접근하면 참조에러(Reference Error)가 발생한다.
// 참조에러는 식별자를 통해 값을 참조하려했지만 자스 엔진이 등록된 식별자를 찾을 수 없을 때 발생한다.


/* 변수 선언의 실행 시점과 변수 호이스팅 */

console.log(score);
var score;

//변수 선언보다 참조가 앞에 있지만 에러가 나지 않는 이유
// 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점(런타임)이 아닌 그 이전 단계에서 먼저 실행되기 때문
// 자스 엔진은 소스코드 실행 전 소스코드평가과정을 거친다
// 이떄 변수 선언을 포함한 모든 선언문을 먼저 실행한다 이 후 평가과정이 끝나면 비로소 선언문을 제외한 소스코드를 실행한다.
// 이렇게 동작하는것을 자바스크립트에서는 변수 호이스팅이라고 한다.


/* 값의 할당 */
// 값을 할당할때는 = (대입연산자) 연산자를 사용한다

var score;
score = 80;
// 위의 변수 선언과 할당을 한줄로
var score = 80;
//으로 표현가능하다.

// 위의 과정을 풀어보자면
var score;
// 이때 score 변수에는 undefined가 할당된다
score = 80;
//이때 80이라는 값을 할당할때 undefined 가 있던 메모리 공간을 지우고 새롭게 80을 저장하는것이 아닌 새로운 메모리공간을 확보 후 그 공간에 80을 저장한다.
//이 과정도 엄밀히 말하자면 재할당이다 처음에 undefined를 할당했다가 80을 다시 할당하는 동작을 하기때문이다.




