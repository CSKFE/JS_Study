/* 원시값과 객체의 비교 */
//자바스크립트의 7가지 데이터 타입(문자열,숫자, blooean, null, undfined, symbol, 객체)은 크게 원시타입과 객체타입으로 나뉜다.
// 원시타입과 객체타입은 세가지 측면에서의 차이가있다
// 원시타입의 값, 즉 불변값(immutable value)이다. 이에 비해 객체타입의 값은 변경가능한 값(mutable value)다
// 원시값을 변수에 할당하면 변수에는 실제 값이 저장된다.
// 이에 반해 객체를 변수에 할당하면 변수가 가지고 있는 메모리 주소를 참조한 메모리 주소값이 저장된다.
// 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사된다(원시 값이 담겨있는 메모리주소값 복사) 이를 값에 의한 전달 이라고 한다
// 이에 비해 객체를 가리키는 변수를 복사하여 다른 변수에 할당하면 원본의 참조 데이터값이 복사되어 전달된다 이를 참조에 의한 전달 이라고 한다.

/* 원시 값 */
// 변경 불가능 한 값
// 원시 타입의 값, 즉 원시값은 변경 불가능한 값이다.
// 한 번 생성된 원시타입의 값은 읽기 전용 값으로서 변경될 수 없다.
// 변수에 값을 할당하고 재할당을 하는 경우 이 경우에서는 처음에 할당되었던 값 자체를 바꾸는게 아닌 새로운 메모리에 값을 담고 그 값을 참조하는 주소를 바꿔주는것이다
// 이것이 원시값의 특징이다, 변경이 불가능하다는것은 변수가 아니라 값에 대한 진술을 의미한다.
// 불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없다.
// 그러면 상수에 할당한 값은 재할당이 가능한가?
// 상수(const)로 선언한 값은 재할당이 불가능하다 한 번만 할당이 가능하다 재할당이 불가능한 변수라고 생각하면 된다, 그렇다고 상수가 불변값은 아니다

//하지만 const로 선언해 할당한 객체의 값은 변경이 가능하다.
const o = {};

o.a = 1;
console.log(o.a); // -> 1


/* 문자열과 불변성 */
// 자바스크립트에서 원시타입의 데이터를 저장할때 미리 데이터의 크기를 예상하여 메모리크기를 확보해야한다
// 이를 위해 원시타입의 값은 미리 메모리공간의 크기가 정해져있다
// 문자열(2바이트) ,숫자(8바이트)
// 이외의 원시타입은 정해진 값을 규정하지않아 브라우저 제조사에따라 다르다
// 문자열은 0개 이상의 문자를 의미하는데 1개의 문자는 2바이트의 공간이 메모리에 저장된다.
// 문자열은 문자의 갯수에 따라 메모리 공간의 크기가 달라진다
// 이에 비해 숫자는 1이던 1000000 이던 8바이트 동일한 크기를 가진다

var str = ''; // 0개의 문자로 이루어진 문자열(빈 문자열)
var str2 = 'hello';  // 5개의 문자로 이루어진 문자열


/* 문자열도 원시값이므로 변경이 불가 */
var str3 = 'hello';
str3 = 'world';
//위의 경우 hello의 값은 원시값이다 따라서 변경이 불가능하다
// str3에 hello 라는값이 할당되었다 world 라는 값으로 재할당되었다
// 이때 hello의 값이 변경되는것이 아닌 새 메모리에 world 라는값을 저장하고 str3 식별자가 참조하는 메모리의 주소를 바꿔준다
// 이는 문자열역시 원시값이기때문에 바뀌지 않는 불변의 특성을 갖고있기 때문이다.

var str4 = 'string';
str4[0] = 'S';
console.log(str4); // => string

//문자열은 원시타입이므로 불변값이다 그러면서 문자열은 유사배열객체의 특성을 갖는다
// 유사배열객체의 특성을 지녔기때문에 각각의 index(length)값에 접근이 가능하며 for문을 사용해서 하나씩 출력도 가능하다
// 그런데 왜 위의 결과는 [0]번의 값이 대문자로 바뀌지 않았을까?
// 문자열은 원시타입의 값으로 불변한 값이다 그렇기때문에 각각의 index에 접근해 값을 바꾸려고해도 불변한 값이고 읽기전용 값이기 때문에 바뀌지 않는것이다.

/* 값에 의한 전달 */

var score = 80;
var copy = score;

console.log(score); // => 80
console.log(copy); // => 80

score = 100;
console.log(score); // => 100
console.log(copy); // => 80

// 변수 score에 80을 할당한 후 score를 변수 copy에 할당했다
// 이때 변수 scroe는 80이라는 원시값을 담고있는 값이다.
// 그러면 copy에 할당되는 값 역시 score가 담고있는 80이 할당된다
// 이처럼 원시값은 갖는 변수를 변수에 할당하면 원시값을 복사하여 할당하게된다
// 이를 값에 의한 전달 이라고 한다
// 이때 score와 copy는 숫자 값 80을 갖는다는것은 동일하지만 서로 다른 메모리공간에 별도로 저장된 별개의 값이다.
// 그렇기때문에 scroe의 값을 100으로 재할당해도 copy의 값은 변하지 않는것이다.
// 결국 값에 의한 전달도 값 자체를 전달하는게 아닌 값이 저장된 메모리 주소를 전달하는것이다.
// 한쪽의 값을 재할당하여 변경하더라도 두 값의 메모리는 서로 간섭할 수 없다, 서로 별개의 값이기 때문이다.


/* 객체 */
// 객체의 프로퍼티는 정해져있지 않다
// 동적으로 생성,삭제도 가능하기때문에 원시값과 같이 메모리공간을 미리 지정할수도없다.
// 객체에서 원시값을 참조하는것은 원시값만을 참조하는것보다 비용이 더 발생한다

//객체타입의 값 즉 객체는 변경가능한 값이다.
var person = {
  name : 'choi'
};
// 원시값을 참조하는 변수는 원시값의 메모리 그 자체를 참조하여 원시값 자체를 값으로 갖는다
// 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조값에 접근할 수 있다
// 참조값은 생성된 객체가 저장된 메모리 주소 그 자체다

/* 얕은 복사과 깊은 복사 */
// 얕은 복사 -> 한 단계의 프로퍼티까지 복사
// 깊은 복사 -> 충접 프로퍼티까지 복사

/* 참조에 의한 전달 */
// 여러개의 식별자가 하나의 객체를 공유할 수 있다

var people = {
  name : 'choi'
};

var objCopy = people;

// 객체를 가리키는 원본(people)을 다른 변수(objCopy)에 할당하면 원본의 참조 값이 복사되어 전달된다
// 이를 참조에 의한 전달 이라고 한다
// 이때 둘 중 하나의 식별자에서 참조하고 있는 객체의 프로퍼티를 변경(삭제,변경,추가)하면 서로 영향을 주고받게된다.


var person2 = {
  name : 'Lee'
};

var personCopy = person2;
console.log(person2 === personCopy); // => true
//서로 같은 값을 참조하기때문에 true

personCopy.name = 'choi';
person2.address = 'Seoul';

console.log(person2);
console.log(personCopy);
// 같은 값을 참조하고 있기때문에 참조된 값에 추가,수정을 하면 서로 영향이있다.
// 사실 참조에 의한 전달도 결국 같은 메모리 주소에서 식별자가 기억하는 메로리공간에 저장되어있는 값을 복사전달하는 면에서 동일하다
// 그렇기때문에 자바스크립트에서는 값에 의한 전달만 존재한다고 할 수 있다.

var person3 = {
  name : 'Lee'
};

var person4 = {
  name : 'Lee'
};

console.log(person3 === person4); // => false;
//두 변수가 참조하는 객체가 내용은 같지만 메모리주소값이 다르다, 서로 다른 메모리의 주소를 참조하므로 false

console.log(person3.name === person4.name)// => true;
// 그러나 두 객체의 프로퍼티(변수) name 은 Lee 라는 원시타입의 값을 참조하므로 true
